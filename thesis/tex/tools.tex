\chapter{Narzędzia}
\section{Formaty zapisu grafów} \label{sec:graph-formats}
Istnieje wiele formatów służących do opisu grafów. Do najpopularniejszych należą \cite{bernard,gephi}

\begin{itemize}
\setlength\itemsep{0em}
\item GML -- \textit{Graph Modeling Language }
\item GraphML -- \textit{Graph Markup Language}
\item GEXF -- \textit{Graph Exchange XML Format}
\item JGF -- \textit{JSON Graph Format}
\item DOT -- format programu Graphviz
\item DGML -- \textit{Directed Graph Markup Language}
\item XGMML -- \textit{eXtensible Graph Markup and Modeling Language}
\end{itemize}

\subsubsection{Graph Markup Language (GraphML)}

GraphML jest formatem zapisu grafów bazującym na składni XML. Format ten wspiera wszystkie typy grafów (skierowane, nieskierowane, mieszane). Wspiera również hipergrafy oraz grafy hierarchiczne. Dodatkowo umożliwia przypisywanie do wierzchołków i krawędzi atrybutów zawierających dane specyficzne dla aplikacji. 

GraphML jest następcą formatu GML (nie będącego standardem XML). Prace nad formatem GML zostały zapoczątkowane przez społeczność \textit{Graph Drawing} podczas Sympozjum Rysowania Grafów w 1995 roku w Pasawie w Niemczech. Pięć lat później przed 8. Międzynarodowym Sympozjum Rysowania Grafów w 2000 roku w Williamsburgu w USA ruszyły prace nad nowym formatem GraphML \cite{graphml}.

Plik w formacie GraphML zawiera element \texttt{graph} (graf), który może zawierać elementy \texttt{node} (wierzchołek), \texttt{edge} (krawędź) oraz \texttt{hyperedge} (hiperkrawędź). Każdy element \texttt{node} powinien zawierać unikalny atrybut \texttt{id} (identyfikator), który jest używany do definiowania krawędzi. Każda krawędź posiada atrybuty \texttt{source} (źródło) oraz \texttt{target} (cel), które odpowiadają identyfikatorom wierzchołków i oznaczają odpowiednio początek i koniec krawędzi. Najwyższym elementem w hierarchii jest \texttt{graphml}, który może zawierać serię elementów \texttt{key} (klucz) służących do definiowania atrybutów danych oraz elementów \texttt{graph}.

Z formatem tym związane są dwa rozszerzenia: \textit{attribute extension} i \textit{parseinfo extension}. Pierwsze z nich pozwala na wyspecyfikowanie typu atrybutu oraz jego nazwy. Drugie dodaje kilka atrybutów do elementów \texttt{graph} i \texttt{node}, takich jak ilość wierzchołków, ilość krawędzi, maksymalny stopień wierzchołka w grafie czy ilość krawędzi wychodzących dla wierzchołka. Metadane te mają na celu pomóc analizatorom składni (parserom) efektywniej przetwarzać pliki z grafami zapisanymi w formacie GraphML. 

Format GraphML wspierają programy yEd Graph Editor oraz w ograniczonym stopniu Gephi (bez hipergrafów i grafów hierarchicznych).

\begin{figure}[h]
\centering
\begin{tikzpicture}
\filldraw 
(0,0) node[label=1](1){}
(1,1) node[label=2](2){} 
(2,0) node[label=3](3){};
\path[draw] (1)--(2);
\path[draw] (2)--(3);
\path[draw] (3)--(1);
\end{tikzpicture}
\caption{} \label{fig:example-graph}
\end{figure}

\begin{listing}[H]
    \caption{Reprezentacja grafu z rysunku \ref{fig:example-graph} w formacie GraphML}
    \inputminted{xml}{example.graphml}
    \label{lst:graphml-example}
\end{listing}

\subsubsection{Graph Exchange XML Format (GEXF)}

GEXF jest formatem opierającym się na XML, który służy do opisywania struktur złożonych sieci. Został stworzony w 2007 roku przez konsorcjum Gephi.  

\begin{listing}[H]
        \caption{Reprezentacja grafu z rysunku \ref{fig:example-graph} w formacie GEXF}
    \inputminted{xml}{example.gexf}
    \label{lst:gexf-example}
\end{listing}

\subsubsection{JSON Graph Format (JGF)} 
\begin{listing}[H]
    \caption{Reprezentacja grafu z rysunku \ref{fig:example-graph} w formacie JGF}
    \inputminted{json}{example.json}
    \label{lst:jgf-example}
\end{listing}

\subsubsection{DOT Graphviz} 
\begin{listing}[H]
    \caption{Reprezentacja grafu z rysunku \ref{fig:example-graph} w formacie DOT}
    \inputminted{text}{example.gv}
    \label{lst:dot-example}
\end{listing}

\section{Biblioteki do wizualizacji grafów w JavaScript}

\subsection{Cytoscape.js}

Biblioteka z otwartym źródłem (ang. \textit{open-source}) do analizy i wizualizacji grafów. Udostępniona na zasadach licencji MIT. Została napisana w czystym JavaScript i nie posiada zależności do żadnych innych bibliotek. Cytoscape.js jest następcą porzuconego projektu Cytoscape Web korzystającego z technologii Adobe Flash \cite[309]{franz}. 

Prawa własności intelektualnej posiada do niej Cytoscape Consortium -- organizacja \textit{non-profit}, która promuje rozwój i dystrybucję oprogramowania związanego z sieciami biologicznymi. Cytoscape.js została stworzona na University of Toronto. Jej głównym kontrybutorem jest Max Franz. Biblioteka została sfinansowana przez granty NRNB (\textit{National Resource for Network Biology}) i NIH (\textit{National Institutes of Health}). Kilka innych uniwersytetów oraz firm również pomagało w rozwoju biblioteki \cite{cytoscape}. 

Cytoscape.js jest kompatybilny z kilkoma przydatnymi bibliotekami oraz środowiskami JavaScript, takimi jak: Node.js, Browserify, webpack, RequireJS czy Bower, co pozwala na integrację z szeroką gamą systemów opartych na JS. 

Architektura Cytoscape.js pozwala na uruchomienie zarówno bez graficznego interfejsu użytkownika oraz jako komponent graficzny, którego implementacja bazuje na elemencie HTML5 Canvas (przykład przedstawiony jest na rysunku \ref{fig:cytoscape}). Umożliwia to korzystanie z biblioteki zarówno po stronie klienta (np. przeglądarka internetowa), jak i po stronie serwera (np. Node.js).

Cytoscape.js wspiera różne typy grafów: skierowane, nieskierowane, multigrafy. Pozwala na dodawanie, usuwanie i modyfikację krawędzi oraz wierzchołków. Biblioteka dostarcza również możliwość grupowania wierzchołków.

W bibliotece jest zaimplementowanych kilka znanych algorytmów takich jak znajdowanie najkrótszej ścieżki, minimalnego drzewa rozpinającego czy minimalnego przekroju. 

style, funkcje mapujące, 
wsparcie dla gestów myszy i urządzeń z ekranami dotykowymi
przesuwanie wierzchołków, zmiana widoku przez przeciąganie lub przybliżanie/oddalanie
wiązanie zdarzeń (ang. \textit{event binding})  
animacje
import i eksport do obrazka (PNG/JPG), JSON (dodatek do GraphML)
układ wierzchołków automatyczny: losowy, siatki (ang. \textit{grid}), okręgu, koncentryczny, zdefiniowany przez przeszukiwanie grafu wszerz (ang. breadth-first search), cose (\textit{Compound Spring Embedder} -- układ korzystający z symulacji fizycznej) lub zdefiniowany przez programistę
rozszerzalność -- możliwość dopisania swoich własnych algorytmów, układów, itd. Wiele istniejących dodatków. 
wydajność -- biblioteka jest w stanie obsłużyć i wyrenderować grafy posiadające tysiące elementów \cite[310]{franz}, wydajność zależy od urządzenia, na którym jest uruchamiany kod, od silnika JS, rozmiaru grafu oraz użytych styli. W szczególności kosztowne do wyrenderowania są grawędzie, zwłaszcza w multigrafach ze względu na konieczność narysowania krzywych beziera. W dokumnetacji online jest wiele wskazówek dotyczących optymalizacji pod kątem wydajności (sekcja \textit{Performance} \cite{cytoscape}).
Cytoscape.js posiada obszerną dokumentację online, która zawiera szczegółowy opis API (ang. \textit{Application Programming Interface} -- interfejs programistyczny), przykłady kawałków kodu oraz działające przykłady. 


\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{cytoscape.png}
\caption{Przykład wizualizacji grafu w Cytoscape.js -- krawędzie mogą mieć różny kolor i grubość, pomiędzy wierzchołkami może istnieć wiele krawędzi oraz wierzchołki mogą mieć różny rozmiar}\label{fig:cytoscape}
\end{figure}

\subsection{sigma.js}
\subsection{VivaGraph.js}
\subsection{Linkurious.js}

\begin{table}[H]
\begin{tabularx}{\textwidth}{|r|c|c|c}
\hline 
 & Cytoscape.js & Sigma & VivaGraphJS \\ 
\hline 
Licencja & MIT & MIT & BSD 3 \\ 
\hline 
Rozmiar & 294 & 112,9 & 60,4 \\ 
\hline 
Renderowanie & & & \\
SVG & • & tak & • \\
HTML5 Canvas & • & tak & • \\
WebGL Canvas & • & tak & • \\ 
\hline 
Obsługiwane formaty & • & • & • \\ 
\hline
Rozszerzalność & • & • & • \\ 
\hline 
• & • & • & • \\ 
\hline 
\end{tabularx} 
\end{table}


